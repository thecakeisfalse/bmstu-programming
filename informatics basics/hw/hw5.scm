
;; homework5

(define feature-if-else #t)
(define feature-nested-if #t)
(define feature-while-loop #t)
(define feature-repeat-loop #t)
(define feature-for-loop #t)
(define feature-break-continue #t)
(define feature-switch-case #t)
(define feature-hi-level #t)
(define feature-tail-call #t)
(define feature-global #t)

(define (interpret-rec program program-size
                       stack ipointer ret table for? switch-value switch? globals)
  (define (->tf v) (if v -1 0))
  (define (tf-> v) (not (= v 0)))

  (define (pop)
    (let ((v (car stack)))
      (set! stack (cdr stack))
      v))

  (define (push value)
    (set! stack (cons value stack)))

  (define (add-func p)
    (set! table (cons (list (vector-ref program p) p) table)))

  (define (skip->endif program ipointer)
    (let loop ((counter 1) (p (+ ipointer 1)))
      (if (= counter 0)
          (- p 1)
          (let ((term (vector-ref program p)))
            (cond
              ((equal? term 'if) (loop (+ counter 1) (+ p 1)))
              ((equal? term 'endif) (loop (- counter 1) (+ p 1)))
              ((and (= counter 1) (equal? term 'else)) p)
              (else (loop counter (+ p 1))))))))

  (define (skip->next program ipointer word)
    (let loop ((p (+ ipointer 1)))
      (cond
        ((equal? (vector-ref program p) word) (- p 1))
        (else (loop (+ p 1))))))

  (define (skip<-startloop program ipointer start end)
    (let loop ((counter 1) (p (- ipointer 1)))
      (if (= counter 0)
          p
          (let ((term (vector-ref program p)))
            (cond
              ((equal? term start) (loop (- counter 1) (- p 1)))
              ((equal? term end) (loop (+ counter 1) (- p 1)))
              (else (loop counter (- p 1))))))))

  (define (skip->endloop program ipointer start end)
    (let loop ((counter 1) (p (+ ipointer 1)))
      (cond
        ((= counter 0) (- p 1))
        ((>= p (vector-length program)) 1e10)
        (else
         (let ((term (vector-ref program p)))
           (cond
             ((equal? term start) (loop (+ counter 1) (+ p 1)))
             ((equal? term end) (loop (- counter 1) (+ p 1)))
             (else (loop counter (+ p 1)))))))))

  (define (skip<-loop program ipointer)
    (inexact->exact
     (max (skip<-startloop program ipointer 'while 'wend)
          (skip<-startloop program ipointer 'for 'next)
          (skip<-startloop program ipointer 'repeat 'until))))

  (define (skip->loop program ipointer)
    (inexact->exact
     (min (skip->endloop program ipointer 'while 'wend)
          (skip->endloop program ipointer 'for 'next)
          (skip->endloop program ipointer 'repeat 'until))))

  (define (defvar)
    (let ((k (vector-ref program (+ ipointer 1)))
          (v (vector-ref program (+ ipointer 2))))
      (set! globals (cons (list k v) globals))
      (set! ipointer (+ ipointer 2))))
 
  (define (setvar)
    (let ((k (vector-ref program (+ ipointer 1)))
          (v (pop)))
      (set-cdr! (assoc k globals) (cons v '()))
      (set! ipointer (+ ipointer 1))))

  (if (< ipointer program-size)
      (let ((term (vector-ref program ipointer)))
        (cond
          ((equal? term 'define)
           (add-func (+ ipointer 1))
           (set! ipointer (skip->next program ipointer 'end)))
          ((equal? term 'end)
           (and (not (null? ret))
                (begin
                  (set! ipointer (car ret))
                  (set! ret (cdr ret)))))
          ((equal? term 'switch)
           (set! switch-value (pop)))
          ((equal? term 'endswitch)
           (set! switch-value #f)
           (set! switch? #f))
          ((equal? term 'case)
           (if switch?
               (set! ipointer (+ ipointer 1))
               (and (= switch-value (vector-ref program (+ ipointer 1)))
                    (begin (set! ipointer (+ ipointer 1))
                           (set! switch? #t)))))
          ((and (not switch?) switch-value) '())
          ((equal? term 'defvar)
           (defvar))
          ((equal? term 'set)
           (setvar))
          ((equal? term 'tail)
           (set! ipointer (+ ipointer 1))
           (set! ipointer (cadr (assoc (vector-ref program ipointer) table))))
          ((equal? term 'lam)
           (push ipointer)
           (set! ipointer (skip->endloop program ipointer 'lam 'endlam)))
          ((equal? term 'endlam)
           (and (not (null? ret))
                (begin (set! ipointer (car ret)) (set! ret (cdr ret)))))
          ((equal? term '&)
           (set! ipointer (+ ipointer 1))
           (push (cadr (assoc (vector-ref program ipointer) table))))
          ((equal? term 'apply)
           (set! ret (cons ipointer ret))
           (set! ipointer (pop)))
          ((equal? term 'while)
           (and (not (tf-> (pop)))
                (set! ipointer (skip->endloop program ipointer 'while 'wend))))
          ((equal? term 'wend)
           (set! ipointer (skip<-startloop program ipointer 'while 'wend)))
          ((equal? term 'for)
           (let ((a (pop)) (b (pop)))
             (if (< a b)
                 (set! ipointer (skip->endloop program ipointer 'for 'next))
                 (begin (set! ret (cons b (cons a ret)))
                        (set! for? #t)))))
          ((equal? term 'next)
           (set! ret (cons (+ (car ret) 1) (cdr ret)))
           (if (> (car ret) (cadr ret))
               (begin (set! ret (cddr ret)) (set! for? #f))
               (set! ipointer (+ 1 (skip<-startloop program ipointer 'for 'next)))))
          ((and for? (equal? term 'i)) (push (car ret)))
          ((equal? term 'break)
           (set! ipointer (skip->loop program ipointer))
           (and (equal? (vector-ref program ipointer) 'next)
                (set! ret (cddr ret))))
          ((equal? term 'continue)
           (set! ipointer (- (skip->loop program ipointer) 1)))
          ((equal? term 'repeat) '())
          ((equal? term 'until)
           (and (not (tf-> (pop))) (set! ipointer (skip<-startloop program ipointer 'repeat 'until))))
          ((equal? term 'if)
           (and (not (tf-> (pop))) (set! ipointer (skip->endif program ipointer))))
          ((equal? term 'else)
           (set! ipointer (skip->endif program ipointer)))
          ((equal? term 'endif) '())
          ((equal? term 'exitcase)
           (and switch? (set! ipointer (skip->next program ipointer 'endswitch))))
          ((number? term) (push term))
          ((equal? term '+) (push (apply + (reverse `(,(pop) ,(pop))))))
          ((equal? term '-) (push (apply - (reverse `(,(pop) ,(pop))))))
          ((equal? term '*) (push (apply * (reverse `(,(pop) ,(pop))))))
          ((equal? term '/) (push (apply quotient (reverse `(,(pop) ,(pop))))))
          ((equal? term 'mod) (push (apply modulo (reverse `(,(pop) ,(pop))))))
          ((equal? term 'neg) (push (- (pop))))
          ((equal? term '=) (push (->tf (= (pop) (pop)))))
          ((equal? term '<) (push (->tf (> (pop) (pop)))))
          ((equal? term '>) (push (->tf (< (pop) (pop)))))
          ((equal? term 'dup) (push (car stack)))
          ((equal? term 'swap) (map push `(,(pop) ,(pop))))
          ((equal? term 'over) (push (cadr stack)))
          ((equal? term 'rot) (map push `(,(pop) ,(pop) ,(pop))))
          ((equal? term 'depth) (push (length stack)))
          ((equal? term 'not) (push (->tf (zero? (pop)))))
          ((equal? term 'and)
           (let ((a (tf-> (pop))) (b (tf-> (pop)))) (push (->tf (and a b)))))
          ((equal? term 'or)
           (let ((a (tf-> (pop))) (b (tf-> (pop)))) (push (->tf (or a b)))))
          ((equal? term 'exit)
           (set! ipointer (car ret))
           (set! ret (cdr ret)))
          ((equal? term 'drop) (pop))
          (else
           (set! ret (cons ipointer ret))
           (if (assoc term globals)
               (push (cadr (assoc term globals)))
               (set! ipointer (cadr (assoc term table))))))
        (interpret-rec program program-size stack (+ ipointer 1)
                       ret table for? switch-value switch? globals))
      stack))

(define (interpret program stack)
  (interpret-rec program (vector-length program) stack 0 '() '() #f #f #f '()))
