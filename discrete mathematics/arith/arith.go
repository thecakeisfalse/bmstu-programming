//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
//⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
//⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
//⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
//⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
//⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
//⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
//⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
//⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
//⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
//⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
//⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

type Tag int

const (
	ERROR  Tag = 1 << iota // Неправильная лексема
	NUMBER                 // Целое число
	VAR                    // Имя переменной
	PLUS                   // Знак +
	MINUS                  // Знак -
	MUL                    // Знак *
	DIV                    // Знак /
	LPAREN                 // Левая круглая скобка
	RPAREN                 // Правая круглая скобка
	EMPTY
)

type Lexem struct {
	Tag
	Image string
}

type Stream struct {
	lexems  chan Lexem
	current Lexem
}

func lexer(expr string, lexems chan Lexem) {
	special := func(ch rune) bool { return strings.Contains("+-*/()", string(ch)) }
	letter := func(ch rune) bool { return ('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') }
	digit := func(ch rune) bool { return '0' <= ch && ch <= '9' }
	space := func(ch rune) bool { return strings.Contains(" \t\n", string(ch)) }

	var number func(string) bool
	number = func(s string) bool {
		if len(s) == 0 {
			return true
		}
		return digit(rune(s[0])) && number(s[1:])
	}

	temp := ""

	for _, x := range expr + "\n" {
		if digit(x) || letter(x) {
			temp += string(x)
		} else {
			if temp != "" && letter(rune(temp[0])) {
				lexems <- Lexem{VAR, temp}
			} else if temp != "" && number(temp) {
				lexems <- Lexem{NUMBER, temp}
			} else if temp != "" && digit(rune(temp[0])) {
				lexems <- Lexem{ERROR, "invalid value"}
			}
			temp = ""

			if special(x) {
				switch x {
				case '+':
					lexems <- Lexem{PLUS, "+"}
				case '-':
					lexems <- Lexem{MINUS, "-"}
				case '*':
					lexems <- Lexem{MUL, "*"}
				case '/':
					lexems <- Lexem{DIV, "/"}
				case '(':
					lexems <- Lexem{LPAREN, "("}
				case ')':
					lexems <- Lexem{RPAREN, ")"}
				}
			} else if !space(x) {
				lexems <- Lexem{ERROR, string(x)}
			}
		}
	}

	close(lexems)
}

func (stream *Stream) peek() Lexem {
	if stream.current.Tag == EMPTY {
		value, ok := <-stream.lexems
		if !ok {
			return stream.current
		}
		stream.current = value
	}
	return stream.current
}

func (stream *Stream) next() Lexem {
	value := stream.peek()
	stream.current = Lexem{EMPTY, ""}
	return value
}

func parseFactor(stream *Stream, globals *map[string]int) (int, string) {
	lx := stream.next()

	if lx.Tag == MINUS {
		result, err := parseFactor(stream, globals)
		return -result, err
	} else if lx.Tag == LPAREN {
		result, err := parseExpr(stream, globals)
		if stream.next().Tag&RPAREN == 0 {
			return -1, "no right paren?"
		}
		return result, err
	} else if lx.Tag == VAR {
		result, ok := (*globals)[lx.Image]
		if ok != true {
			var n int
			fmt.Scanf("%d", &n)
			(*globals)[lx.Image], result = n, n
		}
		return result, "ok"
	} else if lx.Tag == NUMBER {
		result, _ := strconv.Atoi(lx.Image)
		return result, "ok"
	}

	return -1, "invalid word?"
}

func parseTerm(stream *Stream, globals *map[string]int) (int, string) {
	result, err := parseFactor(stream, globals)

	for stream.peek().Tag&(MUL|DIV) != 0 {
		t := stream.next()
		fvalue, ferr := parseFactor(stream, globals)

		if ferr != "ok" {
			return -1, ferr
		}
		if t.Tag == MUL {
			result *= fvalue
		}

		if t.Tag == DIV {
			if fvalue == 0 {
				return -1, "division by zero?"
			}

			result /= fvalue
		}
	}

	return result, err
}

func parseExpr(stream *Stream, globals *map[string]int) (int, string) {
	result, err := parseTerm(stream, globals)

	for stream.peek().Tag&(PLUS|MINUS) != 0 {
		t := stream.next()
		tvalue, terr := parseTerm(stream, globals)
		if terr != "ok" {
			return -1, terr
		}

		if t.Tag == PLUS {
			result += tvalue
		}

		if t.Tag == MINUS {
			result -= tvalue
		}
	}

	return result, err
}

func parse(lexems chan Lexem) (int, string) {
	stream := Stream{lexems, Lexem{EMPTY, ""}}
	result, err := parseExpr(&stream, &map[string]int{})

	if stream.peek().Tag == EMPTY {
		return result, err
	}

	return -1, "invalid last token"
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("error")
		return
	}

	s := os.Args[1]

	lexems := make(chan Lexem)
	go lexer(string(s), lexems)
	result, err := parse(lexems)
	if err == "ok" {
		fmt.Printf("%d\n", result)
	} else {
		fmt.Println("error")
		fmt.Errorf("error: %s\n", err)
	}
}
