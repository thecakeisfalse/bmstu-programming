// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
// ⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
// ⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
// ⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
// ⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
// ⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
// ⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
// ⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
// ⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
// ⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
// ⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

#include <bits/stdc++.h>

using namespace std;

using vpair = vector<pair<int, string>>;
using Automata = vector<vpair>;

const int maxn = 1e5;

int p[maxn], s[maxn];

int find(int v) { return (p[v] == v) ? v : p[v] = find(p[v]); }

void unite(int a, int b) {
    a = find(a), b = find(b);
    if (s[a] > s[b])
        swap(a, b);
    s[b] += s[a];
    p[a] = b;
}

auto split1(const Automata &a, vector<int> &pi) {
    int m = a.size(), n = m;
    for (int i = 0; i < m; ++i)
        p[i] = i, s[i] = 1;

    for (int q1 = 0; q1 < n; ++q1) {
        for (int q2 = 0; q2 < n; ++q2) {
            if (find(q1) != find(q2)) {
                bool eq = true;

                for (int x = 0; x < a[0].size(); ++x) {
                    if (a[q1][x].second != a[q2][x].second) {
                        eq = false;
                        break;
                    }
                }

                if (eq) {
                    unite(q1, q2);
                    m--;
                }
            }
        }
    }

    for (int i = 0; i < n; ++i)
        pi[i] = find(i);

    return m;
}

auto split(const Automata &a, vector<int> &pi) {
    int m = a.size(), n = m;

    for (int i = 0; i < m; ++i)
        p[i] = i, s[i] = 1;

    for (int q1 = 0; q1 < n; ++q1) {
        for (int q2 = 0; q2 < n; ++q2) {
            if (pi[q1] == pi[q2] && find(q1) != find(q2)) {
                bool eq = true;

                for (int x = 0; x < a[0].size(); ++x) {
                    auto w1 = a[q1][x].first, w2 = a[q2][x].first;
                    if (pi[w1] != pi[w2]) {
                        eq = false;
                        break;
                    }
                }

                if (eq) {
                    unite(q1, q2);
                    m--;
                }
            }
        }
    }

    for (int i = 0; i < n; ++i)
        pi[i] = find(i);

    return m;
}

auto AufenkampHohn(const Automata &a, int q0) {
    vector<int> pi(a.size());
    int m = split1(a, pi);

    while (1) {
        int m_ = split(a, pi);
        if (m == m_)
            break;
        m = m_;
    }

    vector<int> delta(a.size()), phi(a.size());
    int count = 0;
    for (int i = 0; i < a.size(); ++i) {
        if (pi[i] == i) {
            delta[count] = i;
            phi[i] = count;
            ++count;
        }
    }

    Automata b(m, vpair(a[0].size()));
    int q0_ = phi[pi[q0]];
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < a[0].size(); ++j) {
            b[i][j].first = phi[pi[a[delta[i]][j].first]];
            b[i][j].second = a[delta[i]][j].second;
        }
    }

    return make_pair(q0_, b);
}

void dfs(const Automata &a, int v, vector<int> &used, int &idx) {
    used[v] = idx++;
    for (auto &[u, _] : a[v])
        if (used[u] == -1)
            dfs(a, u, used, idx);
}

auto canonize(const Automata &a, int q0) {
    vector<int> used(a.size(), -1);
    int idx = 0;

    dfs(a, q0, used, idx);

    Automata b(a), temp(a);
    for (int i = 0; i < a.size(); ++i) {
        int q = used[i];
        for (int j = 0; j < a[0].size(); ++j)
            temp[q][j].first = used[temp[q][j].first];
    }

    for (int i = 0; i < a.size(); ++i)
        b[used[i]] = temp[i];

    return b;
}

auto readMealy() {
    int n, m, q0;
    cin >> n >> m >> q0;

    Automata a(n, vpair(m));

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            cin >> a[i][j].first;

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            cin >> a[i][j].second;

    return make_pair(q0, a);
}

void printMealy(const Automata &a) {
    printf("digraph {\n");
    printf("\trankdir = LR\n");

    for (int i = 0; i < a.size(); ++i) {
        for (int j = 0; j < a[0].size(); ++j) {
            printf("\t%d -> %d [label=\"%c(%s)\"]\n", i, a[i][j].first, 'a' + j,
                   a[i][j].second.c_str());
        }
    }

    printf("}\n");
}

int main() {
    auto [q0, a] = readMealy();
    auto [q0_, b] = AufenkampHohn(a, q0);
    auto c = canonize(b, q0_);
    printMealy(c);
}
