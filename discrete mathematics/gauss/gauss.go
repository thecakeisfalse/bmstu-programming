//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
//⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
//⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
//⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
//⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
//⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
//⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
//⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
//⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
//⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
//⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
//⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

package main

import "fmt"

func Abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}

func Gcd(a, b int) int {
	if a == 0 || b == 0 {
		return a + b
	}
	if a > b {
		return Gcd(b, a)
	}
	return Gcd(b%a, a)
}

type Fraction struct {
	numerator, denominator int
}

type Vector []Fraction
type Matrix []Vector

func (f Fraction) Simplify() Fraction {
	gcd := Gcd(Abs(f.numerator), Abs(f.denominator))
	numerator := f.numerator / gcd
	denominator := f.denominator / gcd
	minus := denominator / Abs(denominator)
	return Fraction{numerator / minus, denominator / minus}
}

func (f Fraction) Add(g Fraction) Fraction {
	numerator := f.numerator*g.denominator + f.denominator*g.numerator
	denominator := f.denominator * g.denominator
	return Fraction{numerator, denominator}.Simplify()
}

func (f Fraction) Sub(g Fraction) Fraction {
	numerator := f.numerator*g.denominator - f.denominator*g.numerator
	denominator := f.denominator * g.denominator
	return Fraction{numerator, denominator}.Simplify()
}

func (f Fraction) Mul(g Fraction) Fraction {
	numerator := f.numerator * g.numerator
	denominator := f.denominator * g.denominator
	return Fraction{numerator, denominator}.Simplify()
}

func (f Fraction) Div(g Fraction) Fraction {
	numerator := f.numerator * g.denominator
	denominator := f.denominator * g.numerator
	return Fraction{numerator, denominator}.Simplify()
}

func PrintMatrix(a Matrix) {
	for _, r := range a {
		for _, v := range r {
			fmt.Printf("%d/%d ", v.numerator, v.denominator)
		}
		fmt.Println("")
	}
	fmt.Println("")
}

func UpperTriangular(a Matrix) (Matrix, bool) {
	for i := 0; i < len(a); i++ {
		base := -1
		for j := i; j < len(a); j++ {
			if a[j][i].numerator != 0 {
				base = j
				break
			}
		}

		if base == -1 {
			return Matrix{}, false
		}

		a[base], a[i] = a[i], a[base]
		for j := len(a); j >= i; j-- {
			for k := len(a) - 1; k >= i; k-- {
				if k == i {
					a[k][j] = a[k][j].Div(a[i][i])
				} else {
					a[k][j] = a[k][j].Sub(a[i][j].Mul(a[k][i]).Div(a[i][i]))
				}
			}
		}
	}

	return a, true
}

func LowerTriangular(a Matrix) (Matrix, bool) {
	for i := len(a) - 1; i >= 0; i-- {
		for j := len(a); j >= i; j-- {
			for k := 0; k < i; k++ {
				a[k][j] = a[k][j].Sub(a[i][j].Mul(a[k][i]))
			}
		}
	}
	return a, true
}

func Gauss(a Matrix) (Vector, bool) {
	a, success := UpperTriangular(a)
	if !success {
		return Vector{}, false
	}

	a, success = LowerTriangular(a)
	if !success {
		return Vector{}, false
	}

	result := make(Vector, len(a))
	for i, row := range a {
		result[i] = row[len(row)-1]
	}

	return result, true
}

func main() {
	var n int
	fmt.Scanf("%d", &n)

	a := make(Matrix, n)
	for i := 0; i < n; i++ {
		a[i] = make(Vector, n+1)
		for j := 0; j <= n; j++ {
			a[i][j] = Fraction{0, 1}
			fmt.Scanf("%d", &a[i][j].numerator)
		}
	}

	result, success := Gauss(a)

	if success {
		for _, v := range result {
			fmt.Printf("%d/%d\n", v.numerator, v.denominator)
		}
	} else {
		fmt.Println("No solution")
	}
}
