//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
//⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
//⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
//⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
//⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
//⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
//⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
//⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
//⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
//⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
//⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
//⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

import java.io.*;
import java.util.*;
import java.util.stream.*;

public class Modules {
    private static class Pair<T, U> {
        private T first;
        private U second;

        public Pair(T first, U second) {
            this.first = first;
            this.second = second;
        }

        public T getFirst() {
            return first;
        }

        public U getSecond() {
            return second;
        }
    }
    private static class Stream<T> {
        private ArrayList<T> stream_;
        private Integer pointer_;

        public Stream(ArrayList<T> s) {
            stream_ = s;
            pointer_ = 0;
        }

        private Pair<T, Boolean> get(Integer p) {
            if (!(p < stream_.size())) {
                return new Pair<>((T) new Object(), false);
            }
            return new Pair<>(stream_.get(p), true);
        }

        public boolean empty() {
            return !(pointer_ < stream_.size());
        }

        public T peek() {
            return get(pointer_).getFirst();
        }

        public ArrayList<T> peekn(Integer n) {
            ArrayList<T> result = new ArrayList<T>();

            for (int i = 0; i < n; ++i) {
                Pair<T, Boolean> v = get(pointer_ + i);
                if (!v.getSecond()) {
                    break;
                }
                result.add(v.getFirst());
            }

            return result;
        }

        public T next() {
            T result = get(pointer_).getFirst();
            skip();
            return result;
        }

        public void skip(Integer k) {
            pointer_ += k;
        }

        public void skip() {
            skip(1);
        }
    }

    private enum TokenType {
        ERROR,
        PLUS,
        MINUS,
        MUL,
        DIV,
        LPAREN,
        RPAREN,
        NEQ,
        LEQ,
        GEQ,
        TERN_IF,
        TERN_ELSE,
        LESS,
        GREATER,
        EQUAL,
        SEP,
        COLON,
        IDENT,
        NUMBER,
        SET,
        EOP
    }

    private static class Token {
        public String value;
        public TokenType type;

        public Token(String value, TokenType type) {
            this.value = value;
            this.type = type;
        }

        public Token() {
            new Token("", TokenType.ERROR);
        }
    }

    private static class Lexer implements Iterable<Token> {
        private Stream<Character> stream_;
        private ArrayList<Token> tokens_;
        private boolean error_;
        private Token[] specials_ = new Token[]{
                new Token("+", TokenType.PLUS),
                new Token("-", TokenType.MINUS),
                new Token("*", TokenType.MUL),
                new Token("/", TokenType.DIV),
                new Token("(", TokenType.LPAREN),
                new Token(")", TokenType.RPAREN),
                new Token("<>", TokenType.NEQ),
                new Token("<=", TokenType.LEQ),
                new Token(">=", TokenType.GEQ),
                new Token("<", TokenType.LESS),
                new Token(">", TokenType.GREATER),
                new Token(":=", TokenType.SET),
                new Token("?", TokenType.TERN_IF),
                new Token(":", TokenType.TERN_ELSE),
                new Token("=", TokenType.EQUAL),
                new Token(";", TokenType.SEP),
                new Token(",", TokenType.COLON)
        };

        public Lexer(String s) {
            Arrays.sort(specials_, (o1, o2) -> {
                if (o1.value.length() == o2.value.length()) {
                    return o1.value.compareTo(o2.value);
                }
                return -(o1.value.length() - o2.value.length());
            });

            this.error_ = false;
            this.tokens_ = new ArrayList<>();
            this.stream_ = new Stream<>(stringToArray(s));

            tokenize();
        }

        public ArrayList<Token> tokens() {
            return this.tokens_;
        }

        public boolean success() {
            return !this.error_;
        }

        public Iterator iterator() {
            return new LexerIterator();
        }

        private void tokenize() {
            while (!stream_.empty() && !error_) {
                if (Character.isDigit(stream_.peek()))
                    tokens_.add(scanNumber());
                else if (Character.isAlphabetic(stream_.peek()))
                    tokens_.add(scanIdent());
                else if (Character.isSpaceChar(stream_.peek()))
                    stream_.skip();
                else
                    tokens_.add(scanSpecial());
            }

            if (stream_.empty()) {
                tokens_.add(new Token("", TokenType.EOP));
            }
        }

        private void error() {
            this.error_ = true;
        }

        private Token scanIdent() {
            StringBuilder result = new StringBuilder(String.valueOf(stream_.next()));

            for (; !stream_.empty(); stream_.skip()) {
                Character cur = stream_.peek();

                if (!(Character.isAlphabetic(cur) || Character.isDigit(cur))) {
                    break;
                }

                result.append(cur);
            }

            return new Token(result.toString(), TokenType.IDENT);
        }

        private Token scanNumber() {
            StringBuilder result = new StringBuilder(String.valueOf(stream_.next()));

            for (; !stream_.empty(); stream_.skip()) {
                Character cur = stream_.peek();

                if (!Character.isDigit(cur)) {
                    break;
                }

                result.append(cur);
            }

            return new Token(result.toString(), TokenType.NUMBER);
        }

        private Token scanSpecial() {
            int max_n = specials_[0].value.length();
            ArrayList<Character> symbols = stream_.peekn(max_n);

            for (Token pattern : specials_) {
                ArrayList<Character> value = stringToArray(pattern.value);
                if (value.size() <= symbols.size()) {
                    boolean isEqual = true;

                    for (int i = 0; i < value.size(); ++i) {
                        if (value.get(i) != symbols.get(i)) {
                            isEqual = false;
                            break;
                        }
                    }

                    if (!isEqual) {
                        continue;
                    }

                    stream_.skip(value.size());
                    return pattern;
                }
            }

            error();

            return new Token();
        }

        private class LexerIterator implements Iterator {
            private int pointer_;
            public LexerIterator() {
                this.pointer_ = 0;
            }

            public boolean hasNext() {
                return this.pointer_ < tokens_.size();
            }

            public Token next() {
                if (!hasNext()) {
                    return new Token();
                }
                Token result = tokens_.get(this.pointer_);
                ++this.pointer_;
                return result;
            }
        }
    }

    private static class Parser {
        private Stream<Token> stream_;
        private HashMap<String, HashSet<String>> dependencies_;
        private HashMap<String, HashSet<String>> arguments_;
        private HashMap<String, Integer> number_of_arguments_;
        private String current_function_;
        private boolean error_;

        public Parser(ArrayList<Token> tokens) {
            dependencies_ = new HashMap<>();
            arguments_ = new HashMap<>();
            number_of_arguments_ = new HashMap<>();
            error_ = false;
            stream_ = new Stream<>(tokens);

            if (!stream_.empty()) {
                parseProgram();
                error_ = error_ || !check(TokenType.EOP);
                error_ = error_ || !(number_of_arguments_.keySet().equals(dependencies_.keySet()));
            }
        }

        public boolean success() {
            return !error_;
        }

        public HashMap<String, HashSet<String>> getDependencies() {
            return dependencies_;
        }

        private boolean check(TokenType tt) {
            return stream_.peek().type == tt;
        }

        private boolean checkComparsionOp() {
            return check(TokenType.EQUAL) || check(TokenType.NEQ) || check(TokenType.LESS) ||
                    check(TokenType.GREATER) || check(TokenType.LEQ) || check(TokenType.GEQ);
        }

        private boolean checkSumOp() {
            return check(TokenType.PLUS) || check(TokenType.MINUS);
        }

        private boolean checkMulOp() {
            return check(TokenType.MUL) || check(TokenType.DIV);
        }

        private void error(String message) {
            //System.out.println(message);
            error_ = true;
        }

        // program ::= function { function }
        private void parseProgram() {
            parseFunction();

            while (!error_ && check(TokenType.IDENT))
                parseFunction();
        }

        // function ::= ident "(" formal-args-list ")" ":=" <expr> ";"
        void parseFunction() {
            if (!check(TokenType.IDENT)) {
                error("IDENT");
                return;
            }

            current_function_ = stream_.next().value;
            dependencies_.put(current_function_, new HashSet<>());
            arguments_.put(current_function_, new HashSet<>());

            if (!check(TokenType.LPAREN)) {
                error("LPAREN");
                return;
            }
            stream_.skip();

            int args_count = parseFormalArgsList();

            if (number_of_arguments_.containsKey(current_function_) &&
                    number_of_arguments_.get(current_function_) != args_count) {
                error("Invalid number of arguments");
                return;
            }

            number_of_arguments_.put(current_function_, args_count);

            if (!check(TokenType.RPAREN)) {
                error("RPAREN");
                return;
            }
            stream_.skip();

            if (!check(TokenType.SET)) {
                error("SET");
                return;
            }
            stream_.skip();

            parseExpr();

            if (!check(TokenType.SEP)) {
                error("SEP");
                return;
            }
            stream_.skip();
        }

        // formal-args-list ::= [ ident-list ]
        int parseFormalArgsList() {
            if (!check(TokenType.IDENT))
                return -1;

            return parseIdentList();
        }

        // ident-list ::= ident { "," ident }
        int parseIdentList() {
            int count = 0;

            while (true) {
                Token ident = stream_.next();
                arguments_.get(current_function_).add(ident.value);
                ++count;

                if (!check(TokenType.COLON))
                    break;

                stream_.skip();
            }

            return count;
        }

        // expr ::= comparsion-expr [ "?" comparsion-expr ":" expr ]
        void parseExpr() {
            parseComparsionExpr();

            if (check(TokenType.TERN_IF)) {
                stream_.skip();
                parseComparsionExpr();

                if (!check(TokenType.TERN_ELSE)) {
                    error("TERN_ELSE");
                    return;
                }
                stream_.skip();

                parseExpr();
            }
        }

        // comparsion-expr ::= arith-expr [ comparsion-op arith-expr ]
        void parseComparsionExpr() {
            parseArithExpr();

            if (checkComparsionOp()) {
                stream_.skip();
                parseArithExpr();
            }
        }

        // arith-expr ::= arith-term { sum-op arith-term }
        void parseArithExpr() {
            parseArithTerm();

            while (checkSumOp()) {
                stream_.skip();
                parseArithTerm();
            }
        }

        // arith-term ::= arith-factor { mul-op arith-factor }
        void parseArithTerm() {
            parseArithFactor();

            while (checkMulOp()) {
                stream_.skip();
                parseArithFactor();
            }
        }

        // arith-factor ::= number | ident | ident "(" actual-args-list ")" |
        //                  "(" expr ")" | "-" arith-factor
        void parseArithFactor() {
            if (check(TokenType.NUMBER)) {
                stream_.skip();
                return;
            }

            if (check(TokenType.IDENT)) {
                Token ident = stream_.next();

                if (check(TokenType.LPAREN)) {
                    String call_function_name = ident.value;
                    dependencies_.get(current_function_).add(call_function_name);
                    stream_.skip();

                    int args_count = parseActialArgsList();

                    if (number_of_arguments_.containsKey(call_function_name) &&
                            number_of_arguments_.get(call_function_name) != args_count) {
                        error("Invalid number of arguments");
                        return;
                    }

                    number_of_arguments_.put(call_function_name, args_count);

                    if (!check(TokenType.RPAREN)) {
                        error("RPAREN");
                        return;
                    }
                    stream_.skip();
                } else {
                    HashSet<String> list = arguments_.get(current_function_);
                    if (!list.contains(ident.value))
                        error("ERROR");
                }

                return;
            }

            if (check(TokenType.LPAREN)) {
                stream_.skip();
                parseExpr();

                if (!check(TokenType.RPAREN)) {
                    error("RPAREN");
                    return;
                }
                stream_.skip();

                return;
            }

            if (check(TokenType.MINUS)) {
                stream_.skip();
                parseArithFactor();
                return;
            }

            error("ERROR");
        }

        // actual-args-list ::= [ expr-list ]
        int parseActialArgsList() {
            if (check(TokenType.RPAREN))
                return -1;

            return parseExprList();
        }

        // expr-list ::= expr { "," expr }
        int parseExprList() {
            int count = 0;

            while (true) {
                parseExpr();
                ++count;

                if (!check(TokenType.COLON)) {
                    break;
                }

                stream_.skip();
            }

            return count;
        }
    }

    private static class Graph {
        private HashMap<String, Integer> vertexID_;
        private ArrayList<ArrayList<Integer>> adj_;
        private Integer size_;
        private Integer time_, ssc_count_;

        public Graph() {
            vertexID_ = new HashMap<>();
            adj_ = new ArrayList<>();
            size_ = time_ = ssc_count_ = 0;
        }

        public void addVertex(String vertex) {
            vertexID_.put(vertex, size_);
            adj_.add(new ArrayList<>());
            ++size_;
        }

        public void addEdge(String from, String to) {
            int fromID = vertexID_.get(from);
            int toID = vertexID_.get(to);
            adj_.get(fromID).add(toID);
        }

        public Integer getSSCCount() {
            return Tarjan();
        }

        private void TarjanSearch(int v, int disc[], int low[], int comps[], Stack<Integer> stack) {
            disc[v] = low[v] = time_;
            ++time_;

            stack.push(v);

            for (int u : adj_.get(v)) {
                if (disc[u] == -1) {
                    TarjanSearch(u, disc, low, comps, stack);
                }

                if (comps[u] == -1 && low[v] > low[u]) {
                    low[v] = low[u];
                }
            }

            if (disc[v] == low[v]) {
                int u;
                do {
                    u = stack.pop();
                    comps[u] = ssc_count_;
                } while (u != v);
                ++ssc_count_;
            }
        }

        private Integer Tarjan() {
            int disc[] = new int[size_];
            int low[] = new int[size_];
            int comps[] = new int[size_];
            for (int i = 0; i < size_; ++i) {
                disc[i] = low[i] = comps[i] = -1;
            }

            Stack<Integer> stack = new Stack<>();
            for (int v = 0; v < size_; ++v) {
                if (disc[v] == -1) {
                    TarjanSearch(v, low, disc, comps, stack);
                }
            }

            return ssc_count_;
        }

        public void print() {
            for (int v = 0; v < size_; ++v) {
                System.out.printf("%d: ", v);
                for (Integer u : adj_.get(v)) {
                    System.out.printf("%d ", u);
                }
                System.out.println();
            }
        }
    }

    private static ArrayList<Character> stringToArray(String s) {
        return (ArrayList<Character>) s.chars().mapToObj(e -> (char)e).collect(Collectors.toList());
    }

    private static String getProgram() {
        InputStream input = System.in;
        Scanner scanner = new Scanner(input);
        StringBuilder program = new StringBuilder();
        while (scanner.hasNextLine()) {
            program.append(scanner.nextLine());
        }
        return program.toString();
    }

    private static Graph graphFromDependencies(HashMap<String, HashSet<String>> deps) {
        Graph g = new Graph();

        for (String vertex : deps.keySet()) {
            g.addVertex(vertex);
        }

        for (String to : deps.keySet()) {
            for (String from : deps.get(to)) {
                if (!Objects.equals(to, from)) {
                    g.addEdge(to, from);
                }
            }
        }

        return g;
    }

    public static void main(String[] args) {
        String program = getProgram();

        Lexer l = new Lexer(program);
        if (!l.success()) {
            System.out.println("error");
            return;
        }

        Parser p = new Parser(l.tokens());
        if (!p.success()) {
            System.out.println("error");
            return;
        }

        HashMap<String, HashSet<String>> deps = p.getDependencies();
        Graph g = graphFromDependencies(deps);
        System.out.println(g.getSSCCount());
    }
}