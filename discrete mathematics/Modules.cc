// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
// ⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
// ⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
// ⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
// ⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
// ⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
// ⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
// ⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
// ⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
// ⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
// ⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

#include <algorithm>
#include <ctype.h>
#include <iostream>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#define ASSERT(t)                                                                                  \
    {                                                                                              \
        if (stream_.peek().type != t)                                                              \
            return error(#t);                                                                      \
        stream_.skip();                                                                            \
    }

#define CHECK(t) (stream_.peek().type == t)

using namespace std;

typedef unordered_set<string> stringSet;
typedef unordered_map<string, stringSet> stringMap;
typedef vector<int> vi;
typedef vector<vi> Graph;

template <typename T, typename E, typename V>
bool allEqualKeysMaps(unordered_map<T, E> m1, unordered_map<T, V> m2) {
    for (auto [key1, value1] : m1)
        if (m2.find(key1) == m2.end())
            return false;

    for (auto [key2, value2] : m2)
        if (m1.find(key2) == m1.end())
            return false;

    return true;
}

template <typename T, typename E> class Stream {
  private:
    T stream_;
    size_t pointer_;

    pair<E, bool> get(size_t p) {
        if (!(p < stream_.size()))
            return {E(), false};

        return {stream_[p], true};
    }

  public:
    Stream(T s) : stream_(s), pointer_(0) {}

    E peek() { return get(pointer_).first; }

    vector<E> peekn(size_t n) {
        vector<E> result;

        for (size_t i = 0; i < n; ++i) {
            auto [k, valid] = get(pointer_ + i);
            if (!valid)
                break;
            result.push_back(k);
        }

        return result;
    }

    E next() { return get(pointer_++).first; }

    void skip(size_t k = 1) { pointer_ += k; }

    bool empty() { return pointer_ >= stream_.size(); }
};

enum TokenType {
    ERROR,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    NEQ,
    LEQ,
    GEQ,
    TERN_IF,
    TERN_ELSE,
    LESS,
    GREATER,
    EQUAL,
    SEP,
    COLON,
    IDENT,
    NUMBER,
    SET,
    EOP
};

struct Token {
    string value;
    TokenType type;
};

class Lexer {
  private:
    typedef vector<Token>::iterator iterator;

    bool error_;

    vector<Token> tokens_;
    Stream<string, char> stream_;

    vector<Token> specials_ = {
        {"+", PLUS},    {"-", MINUS}, {"*", MUL},     {"/", DIV},  {"(", LPAREN},    {")", RPAREN},
        {":=", SET},    {"<>", NEQ},  {"<=", LEQ},    {">=", GEQ}, {":", TERN_ELSE}, {"<", LESS},
        {">", GREATER}, {"=", EQUAL}, {"?", TERN_IF}, {";", SEP},  {",", COLON}};

    Token scanIdent() {
        string result(1, stream_.next());

        for (; !stream_.empty(); stream_.skip()) {
            char cur = stream_.peek();

            if (!isalnum(cur))
                break;

            result.push_back(cur);
        }

        return {result, IDENT};
    }

    Token scanNumber() {
        string result(1, stream_.next());

        for (; !stream_.empty(); stream_.skip()) {
            char cur = stream_.peek();

            if (!isdigit(cur))
                break;

            result.push_back(cur);
        }

        return {result, NUMBER};
    }

    Token scanSpecial() {
        int max_n = specials_[0].value.length();
        vector<char> symb = stream_.peekn(max_n);

        for (auto [value, type] : specials_) {
            if (value.length() <= symb.size()) {
                bool equal = true;

                for (size_t i = 0; i < value.length(); ++i) {
                    if (value[i] != symb[i]) {
                        equal = false;
                        break;
                    }
                }

                if (!equal)
                    continue;

                stream_.skip(value.size());
                return {value, type};
            }
        }

        error();

        return {"(T-T)", ERROR};
    }

    void error() { error_ = true; }

    void tokenize() {
        while (!stream_.empty() && !error_) {
            if (isdigit(stream_.peek()))
                tokens_.push_back(scanNumber());
            else if (isalpha(stream_.peek()))
                tokens_.push_back(scanIdent());
            else if (isspace(stream_.peek()))
                stream_.next();
            else
                tokens_.push_back(scanSpecial());
        }

        if (stream_.empty())
            tokens_.push_back({"", EOP});
    }

  public:
    Lexer(const string &s) : error_(false), stream_(s) {
        auto comp = [&](auto left, auto right) {
            auto [left_k, left_v] = left;
            auto [right_k, right_v] = right;
            return left_k.size() > right_k.size() ||
                   (left_k.size() == right_k.size() && left_k < right_k);
        };

        sort(specials_.begin(), specials_.end(), comp);

        tokenize();
    }

    vector<Token> tokens() { return this->tokens_; }
    bool success() { return !error_; }

    iterator begin() { return this->tokens_.begin(); }
    iterator end() { return this->tokens_.end(); }
};

class Parser {
  private:
    Stream<vector<Token>, Token> stream_;

    stringMap dependencies_;
    stringMap arguments_;
    unordered_map<string, int> number_of_arguments_;

    string current_func_;

    bool error_;

    bool checkComparsionOp() {
        return CHECK(EQUAL) || CHECK(NEQ) || CHECK(LESS) || CHECK(GREATER) || CHECK(LEQ) ||
               CHECK(GEQ);
    }

    bool checkSumOp() { return CHECK(PLUS) || CHECK(MINUS); }

    bool checkMulOp() { return CHECK(MUL) || CHECK(DIV); }

    void error(__attribute__((unused)) string expected) {
        // cout << "ERROR" << "\n";
        // cout << "expected: " << expected << "\n";
        // cout << "got: " << stream_.peek().value << "\n";
        error_ = true;
    }

    // program ::= function { function }
    void parseProgram() {
        parseFunction();

        while (!error_ && CHECK(IDENT))
            parseFunction();
    }

    // function ::= ident "(" formal-args-list ")" ":=" <expr> ";"
    void parseFunction() {
        if (!CHECK(IDENT))
            return error("IDENT");

        current_func_ = stream_.next().value;
        dependencies_[current_func_] = stringSet();

        ASSERT(LPAREN);

        int args_count = parseFormalArgsList();
        unordered_map<string, int>::iterator it;
        if ((it = number_of_arguments_.find(current_func_)) != number_of_arguments_.end() &&
            (*it).second != args_count) {
            return error("Invalid number of arguments");
        }
        number_of_arguments_[current_func_] = args_count;

        ASSERT(RPAREN);
        ASSERT(SET);

        parseExpr();

        ASSERT(SEP);
    }

    // formal-args-list ::= [ ident-list ]
    int parseFormalArgsList() {
        if (!CHECK(IDENT))
            return -1;

        return parseIdentList();
    }

    // ident-list ::= ident { "," ident }
    int parseIdentList() {
        int count = 0;

        while (1) {
            auto ident = stream_.next();
            arguments_[current_func_].insert(ident.value);
            ++count;

            if (!CHECK(COLON))
                break;

            stream_.skip();
        }

        return count;
    }

    // expr ::= comparsion-expr [ "?" comparsion-expr ":" expr ]
    void parseExpr() {
        parseComparsionExpr();

        if (CHECK(TERN_IF)) {
            stream_.skip();
            parseComparsionExpr();
            ASSERT(TERN_ELSE);
            parseExpr();
        }
    }

    // comparsion-expr ::= arith-expr [ comparsion-op arith-expr ]
    void parseComparsionExpr() {
        parseArithExpr();

        if (checkComparsionOp()) {
            stream_.skip();
            parseArithExpr();
        }
    }

    // arith-expr ::= arith-term { sum-op arith-term }
    void parseArithExpr() {
        parseArithTerm();

        while (checkSumOp()) {
            stream_.skip();
            parseArithTerm();
        }
    }

    // arith-term ::= arith-factor { mul-op arith-factor }
    void parseArithTerm() {
        parseArithFactor();

        while (checkMulOp()) {
            stream_.skip();
            parseArithFactor();
        }
    }

    // arith-factor ::= number | ident | ident "(" actual-args-list ")" |
    //                  "(" expr ")" | "-" arith-factor
    void parseArithFactor() {
        if (CHECK(NUMBER)) {
            stream_.skip();
            return;
        }

        if (CHECK(IDENT)) {
            auto ident = stream_.next();

            if (CHECK(LPAREN)) {
                string call_function = ident.value;
                dependencies_[current_func_].insert(call_function);
                stream_.skip();

                int args_count = parseActialArgsList();
                unordered_map<string, int>::iterator it;
                if ((it = number_of_arguments_.find(call_function)) != number_of_arguments_.end() &&
                    (*it).second != args_count) {
                    return error("Invalid number of arguments");
                }
                number_of_arguments_[call_function] = args_count;

                ASSERT(RPAREN);
            } else {
                auto list = arguments_[current_func_];

                if (list.find(ident.value) == list.end())
                    error("ERROR");
            }

            return;
        }

        if (CHECK(LPAREN)) {
            stream_.skip();
            parseExpr();
            ASSERT(RPAREN);
            return;
        }

        if (CHECK(MINUS)) {
            stream_.skip();
            parseArithFactor();
            return;
        }

        error("ERROR");
    }

    // actual-args-list ::= [ expr-list ]
    int parseActialArgsList() {
        if (CHECK(RPAREN))
            return -1;

        return parseExprList();
    }

    // expr-list ::= expr { "," expr }
    int parseExprList() {
        int count = 0;

        while (1) {
            parseExpr();
            ++count;

            if (!CHECK(COLON))
                break;

            stream_.skip();
        }

        return count;
    }

  public:
    Parser(const vector<Token> &tokens) : stream_(tokens), error_(false) {
        if (!stream_.empty()) {
            parseProgram();
            error_ = error_ || !CHECK(EOP);
            error_ = error_ ||
                     !allEqualKeysMaps<string, stringSet, int>(dependencies_, number_of_arguments_);
        }
    }

    bool success() { return !error_; }

    stringMap getDependencies() { return dependencies_; }
};

string getProgram() {
    string program = "", line;

    while (getline(cin, line))
        program += line;

    return program;
}

Graph dependenciesToGraph(const stringMap &deps) {
    int n = deps.size();

    Graph g(n, vector<int>());

    unordered_map<string, int> names;
    int counter = 0;

    for (auto k : deps)
        names[k.first] = counter++;

    for (auto [k, vv] : deps) {
        auto k_it = names[k];

        for (auto v : vv) {
            auto v_it = names[v];
            if (v_it != k_it)
                g[v_it].push_back(k_it);
        }
    }

    return g;
}

void TarjanSearch(const Graph &g, int v, stack<int> &s, int &count, int &time, vi &entrance,
                  vi &low, vi &components) {
    entrance[v] = low[v] = time++;

    s.push(v);

    for (int u : g[v]) {
        if (entrance[u] == 0)
            TarjanSearch(g, u, s, count, time, entrance, low, components);

        if (components[u] == 0 && low[v] > low[u])
            low[v] = low[u];
    }

    if (entrance[v] == low[v]) {
        int u;

        do {
            u = s.top();
            s.pop();
            components[u] = count;
        } while (u != v);

        count++;
    }
}

int Tarjan(const Graph &g) {
    int n = g.size();
    int time = 1, count = 1;

    vi entrance(n), low(n), components(n);

    stack<int> s;
    for (int v = 0; v < n; ++v)
        if (entrance[v] == 0)
            TarjanSearch(g, v, s, count, time, entrance, low, components);

    return count - 1;
}

int main() {
    auto program = getProgram();

    Lexer l(program);

    if (!l.success()) {
        cout << "error\n";
        return 0;
    }

    Parser p(l.tokens());

    if (!p.success()) {
        cout << "error\n";
        return 0;
    }

    auto deps = p.getDependencies();
    auto g = dependenciesToGraph(deps);
    cout << Tarjan(g) << "\n";
}