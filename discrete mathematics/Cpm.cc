// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
// ⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
// ⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
// ⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
// ⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
// ⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
// ⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
// ⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
// ⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
// ⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
// ⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

#include <algorithm>
#include <iostream>
#include <queue>
#include <sstream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

typedef pair<int, int> pii;
typedef vector<int> vi;
typedef unordered_set<int> set;

const int INF = 1e9;

enum Colors { WHITE, BLUE, RED, GREY, BLACK };

struct Vertex {
    string name;
    int id;
    int weight;
    int color;

    Vertex(string name, int id, int weight) : name(name), id(id), weight(weight), color(WHITE) {}
};

class Graph {
  private:
    vector<set> adj_, par_;
    unordered_map<string, int> vertexID_;
    vector<Vertex> vertices_;
    size_t size_;

  public:
    Graph() : size_(0) {}

    void addVertex(string v, int w) {
        vertexID_[v] = size_;
        vertices_.push_back(Vertex(v, size_, w));
        adj_.push_back(set());
        ++size_;
    }

    void addEdge(string from, string to) {
        int from_id = vertexID_[from], to_id = vertexID_[to];
        adj_[from_id].insert(to_id);
    }

    void dfs(int v, vector<int> &used) {
        if (used[v] == BLACK)
            return;

        if (used[v] == GREY)
            return colorBlueVertix(v);

        used[v] = GREY;

        for (auto u : adj_[v])
            dfs(u, used);

        used[v] = BLACK;
    }

    void colorBlueVertix(int v) {
        for (auto u : adj_[v]) {
            if (vertices_[u].color == WHITE) {
                vertices_[u].color = BLUE;
                colorBlueVertix(u);
            }
        }
    }

    void colorBlueVertices(void) {
        vector<int> used(size_, WHITE);
        for (size_t v = 0; v < size_; ++v)
            if (used[v] == WHITE)
                dfs(v, used);
    }

    void colorRedVertices(void) {
        vi d(size_, -INF);
        par_.assign(size_, set());

        dijkstra(d, par_);

        int max_distance = *max_element(d.begin(), d.end());

        queue<int> s;
        for (size_t v = 0; v < size_; ++v) {
            if (d[v] == max_distance)
                s.push(v);

            while (!s.empty()) {
                int v = s.front();
                s.pop();

                if (vertices_[v].color != WHITE)
                    continue;

                vertices_[v].color = RED;
                for (auto u : par_[v])
                    s.push(u);
            }
        }
    }

    void dijkstra(vi &d, vector<set> &p) {
        priority_queue<pii, vector<pii>> q;

        for (size_t s = 0; s < size_; ++s) {
            if (vertices_[s].color != WHITE)
                continue;

            d[s] = max(d[s], vertices_[s].weight);

            q.push({d[s], s});

            while (!q.empty()) {
                auto [cur_d, v] = q.top();
                q.pop();

                if (cur_d < d[v] || vertices_[v].color != WHITE)
                    continue;

                for (auto u : adj_[v]) {
                    int w = vertices_[u].weight;

                    if (vertices_[u].color != WHITE)
                        continue;

                    if (d[v] + w > d[u]) {
                        d[u] = d[v] + w;
                        q.push({d[u], u});
                        p[u] = set({v});
                    } else if (d[v] + w == d[u]) {
                        p[u].insert(v);
                    }
                }
            }
        }
    }

    void printDOT() {
        cout << "digraph {\n";

        for (auto v : vertices_) {
            auto name = v.name.c_str();
            printf("\t%s [label = \"%s(%d)\"", name, name, v.weight);
            if (v.color == BLUE)
                printf(", color = blue");
            if (v.color == RED)
                printf(", color = red");
            printf("]\n");
        }

        for (auto v : vertices_) {
            for (auto uID : adj_[v.id]) {
                auto u = vertices_[uID];
                printf("\t%s -> %s", v.name.c_str(), u.name.c_str());

                if (v.color == BLUE)
                    cout << " [color = blue]";

                if (v.color == RED && u.color == RED && par_[uID].count(v.id) > 0)
                    cout << " [color = red]";

                cout << "\n";
            }
        }

        cout << "}\n";
    }
};

string getInput() {
    string input = "", line;

    while (getline(cin, line))
        input += line;

    for (char c : " \t\n\r")
        input.erase(remove(input.begin(), input.end(), c), input.end());

    return input;
}

Graph inputToGraph(const string &s) {
    Graph g;
    stringstream ss(s);
    int t;

    for (string l, last = ""; getline(ss, l, ';'); last = "") {
        stringstream sl(l);

        for (string proc, name, cost; getline(sl, proc, '<'); last = name) {
            if ((t = proc.find('(')) != -1) {
                name = proc.substr(0, t);
                cost = proc.substr(t + 1, proc.find(')') - t - 1);
                g.addVertex(name, stoi(cost));
            } else
                name = proc;

            if (last != "")
                g.addEdge(last, name);
        }
    }

    return g;
}

int main() {
    auto input = getInput();
    auto g = inputToGraph(input);

    g.colorBlueVertices();
    g.colorRedVertices();

    g.printDOT();
}