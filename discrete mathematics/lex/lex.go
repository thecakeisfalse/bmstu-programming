//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
//⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
//⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
//⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
//⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
//⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
//⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
//⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
//⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
//⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
//⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
//⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
//⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
//⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

package main

import (
	"bufio"
	"fmt"
	"math/rand"
	"os"
	"strings"
)

const INF = 1e9

type AssocArray interface {
	Assign(s string, x int)
	Lookup(s string) (x int, exists bool)
}

// === Skip List ===

type SkipNode struct {
	key   string
	value int
	next  []*SkipNode
}

type SkipList struct {
	root *SkipNode
	m    int
}

func makeSkipList() SkipList {
	a := SkipList{m: 26}
	a.root = a.NewNode("($-$)", INF)
	return a
}

func (list SkipList) NewNode(key string, value int) *SkipNode {
	n := SkipNode{key: key, value: value}

	n.next = make([]*SkipNode, list.m)

	for i := 0; i < list.m; i++ {
		n.next[i] = nil
	}

	return &n
}

func (list SkipList) Skip(key string) []*SkipNode {
	x := list.root
	p := make([]*SkipNode, list.m)

	for i := list.m - 1; i >= 0; i-- {
		for x.next[i] != nil && strings.Compare(x.next[i].key, key) < 0 {
			x = x.next[i]
		}
		p[i] = x
	}

	return p
}

func (list SkipList) Assign(s string, x int) {
	p := list.Skip(s)

	testNode := p[0].next[0]
	if testNode != nil && testNode.key == s {
		testNode.value = x
		return
	}

	r := rand.Int()%list.m + 1
	n := list.NewNode(s, x)

	for i := 0; i < r; i++ {
		n.next[i] = p[i].next[i]
		p[i].next[i] = n
	}
}

func (list SkipList) Lookup(s string) (x int, exists bool) {
	p := list.Skip(s)
	res := p[0].next[0]
	if res != nil && res.key == s {
		return res.value, true
	}
	return INF, false
}

// === AVL Tree ===

type AVLNode struct {
	key         string
	value       int
	balance     int
	parent      *AVLNode
	left, right *AVLNode
}

type AVLTree struct {
	root *AVLNode
}

func makeAVL() *AVLTree {
	return &AVLTree{root: nil}
}

func (tree *AVLTree) NewNode(key string, value int) *AVLNode {
	return &AVLNode{key: key, value: value, balance: INF, left: nil, right: nil}
}

func (tree *AVLTree) Descend(key string) *AVLNode {
	result := tree.root

	for result != nil && result.key != key {
		if strings.Compare(key, result.key) < 0 {
			result = result.left
		} else {
			result = result.right
		}
	}

	return result
}

func (tree *AVLTree) Insert(key string, value int) *AVLNode {
	n := tree.NewNode(key, value)

	if tree.root == nil {
		tree.root = n
	} else {
		parent := tree.root
		for {
			cmp := strings.Compare(key, parent.key)
			if cmp < 0 {
				if parent.left == nil {
					parent.left = n
					n.parent = parent
					break
				}
				parent = parent.left
			} else if cmp > 0 {
				if parent.right == nil {
					parent.right = n
					n.parent = parent
					break
				}
				parent = parent.right
			}
		}
	}

	return n
}

func (tree *AVLTree) ReplaceNode(before, after *AVLNode) {
	if before == tree.root {
		tree.root = after
		if after != nil {
			after.parent = nil
		}
	} else {
		parent := before.parent

		if after != nil {
			after.parent = parent
		}

		if parent.left == before {
			parent.left = after
		} else {
			parent.right = after
		}
	}
}

func (tree *AVLTree) RotateRight(n *AVLNode) {
	left := n.left
	tree.ReplaceNode(n, left)

	right := left.right
	if right != nil {
		right.parent = n
	}

	n.left = right
	n.parent = left
	left.right = n

	n.balance += 1
	if left.balance < 0 {
		n.balance -= left.balance
	}

	left.balance += 1
	if n.balance > 0 {
		left.balance += n.balance
	}
}

func (tree *AVLTree) RotateLeft(n *AVLNode) {
	right := n.right
	tree.ReplaceNode(n, right)

	left := right.left
	if left != nil {
		left.parent = n
	}

	n.right = left
	n.parent = right
	right.left = n

	n.balance -= 1
	if right.balance < 0 {
		n.balance -= right.balance
	}

	right.balance -= 1
	if n.balance > 0 {
		right.balance += n.balance
	}
}

func (tree *AVLTree) Assign(s string, x int) {
	node := tree.Descend(s)
	if node != nil {
		node.value = x
		return
	}

	n := tree.Insert(s, x)
	n.balance = 0
	for {
		parent := n.parent
		if parent == nil {
			break
		}

		if n == parent.left {
			parent.balance -= 1
			if parent.balance == 0 {
				break
			}

			if parent.balance == -2 {
				if n.balance == 1 {
					tree.RotateLeft(n)
				}
				tree.RotateRight(parent)
				break
			}
		} else {
			parent.balance += 1
			if parent.balance == 0 {
				break
			}

			if parent.balance == 2 {
				if n.balance == -1 {
					tree.RotateRight(n)
				}
				tree.RotateLeft(parent)
				break
			}
		}
		n = parent
	}
}

func (tree *AVLTree) Lookup(s string) (x int, exists bool) {
	result := tree.Descend(s)

	if result != nil && result.key == s {
		return result.value, true
	}

	return -1, false
}

// === Lexer ===

func lex(sentence string, array AssocArray) []int {
	ids := make([]int, 0)

	isalpha := func(ch byte) bool { return ('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') }
	isdigit := func(ch byte) bool { return '0' <= ch && ch <= '9' }
	isident := func(ch byte) bool { return isalpha(ch) || isdigit(ch) }
	isspace := func(ch byte) bool { return strings.Contains(" \t\n", string(ch)) }

	scanIdent := func(p *int) string {
		result := ""
		for ; *p < len(sentence) && isident(sentence[*p]); *p++ {
			result += string(sentence[*p])
		}
		return result
	}

	unique := 0
	for p := 0; p < len(sentence); {
		if isspace(sentence[p]) {
			p++
		} else if isalpha(sentence[p]) {
			ident := scanIdent(&p)
			result, success := array.Lookup(ident)

			if success {
				ids = append(ids, result)
			} else {
				unique++
				array.Assign(ident, unique)
				ids = append(ids, unique)
			}
		} else {
			fmt.Printf("Invalid input. Expected ident, got '%c'\n", sentence[p])
			break
		}
	}

	return ids
}

// === Main code ===

func main() {
	reader := bufio.NewReader(os.Stdin)
	s, _, _ := reader.ReadLine()

	equalArrays := func(a, b []int) bool {
		if len(a) != len(b) {
			return false
		}

		for i := 0; i < len(a); i++ {
			if a[i] != b[i] {
				return false
			}
		}

		return true
	}

	testAVL := func(s string) []int {
		return lex(s, makeAVL())
	}

	testSkipList := func(s string) []int {
		return lex(s, makeSkipList())
	}

	avlResult := testAVL(string(s))
	skipResult := testSkipList(string(s))

	if !equalArrays(avlResult, skipResult) {
		fmt.Println("Oops... Something went wrong.\nWe'll fix that issue in 5-7 business days :-)")
		return
	}

	for _, value := range avlResult {
		fmt.Printf("%d ", value)
	}
	fmt.Println()
}
