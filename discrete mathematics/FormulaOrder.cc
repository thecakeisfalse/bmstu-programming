// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣤⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣖⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⢠⣄⣀⣠⣤⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠉⠻⣿⣿⣿⣿⣿⣿⣯⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀
// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀
// ⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀
// ⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀
// ⠠⣾⣿⢿⣿⣿⣿⣿⡿⠁⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠉⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡿⠑⠊⣿⣿⡿⠿⠛⠛⠙⠛⣻⣿⣿⣄⡻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡗⠾⠛⠉⠉⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀
// ⠀⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠟⠛⠻⣿⣿⣿⣿⣿⣿⡄⠀
// ⠀⠀⠀⠀⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢶⡋⠳⢸⣿⣿⣿⣿⣿⣇⠀
// ⠀⠂⠀⠀⠘⣿⣿⣿⡀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡗⠚⢁⣠⣾⣿⣿⣿⣿⣿⣿⠀
// ⠀⠉⠀⠀⠀⠈⣻⣿⣿⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣷⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
// ⠀⠀⠀⢺⣿⠤⠿⢿⣿⣿⣿⣿⣿⣿⣷⣶⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
// ⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⣀⡠⠜⠋⠁⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁
// ⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡿⠛⣠⣟⣁⠤⠖⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀
// ⠀⠀⠀⠀⠀⠀⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⡟⢸⠿⠃⠀
// ⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣆⠀⠀⠀⠀⠀⠀
//

#include <algorithm>
#include <ctype.h>
#include <iostream>
#include <queue>
#include <sstream>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#define ASSERT(t)                                                                                  \
    {                                                                                              \
        if (stream_.peek().type != t)                                                              \
            return error(#t);                                                                      \
        stream_.skip();                                                                            \
    }

#define CHECK(t) (stream_.peek().type == t)

using namespace std;

typedef unordered_set<string> stringSet;
typedef unordered_map<string, stringSet> stringMap;
typedef unordered_map<string, int> stringToInt;
typedef vector<int> vi;

template <typename T, typename E> class Stream {
  private:
    T stream_;
    size_t pointer_;

    pair<E, bool> get(size_t p) {
        if (empty())
            return {E(), false};

        return {stream_[p], true};
    }

  public:
    Stream(T s) : stream_(s), pointer_(0) {}

    E peek() { return get(pointer_).first; }

    vector<E> peekn(size_t n) {
        vector<E> result;

        for (size_t i = 0; i < n; ++i) {
            auto [k, valid] = get(pointer_ + i);
            if (!valid)
                break;
            result.push_back(k);
        }

        return result;
    }

    E next() { return get(pointer_++).first; }

    void skip(size_t k = 1) { pointer_ += k; }

    bool empty() { return pointer_ >= stream_.size(); }
};

enum TokenType {
    ERROR,
    PLUS,
    MINUS,
    MUL,
    DIV,
    LPAREN,
    RPAREN,
    SET,
    NUMBER,
    IDENT,
    COLON,
    SEP,
    EOP
};

struct Token {
    string value;
    TokenType type;
};

class Lexer {
  private:
    typedef vector<Token>::iterator iterator;

    bool error_;

    vector<Token> tokens_;
    Stream<string, char> stream_;

    vector<Token> specials_ = {{"+", PLUS},   {"-", MINUS},  {"*", MUL}, {"/", DIV},  {";", SEP},
                               {"(", LPAREN}, {")", RPAREN}, {"=", SET}, {",", COLON}};

    Token scanIndent() {
        string result(1, stream_.next());

        for (; !stream_.empty(); stream_.skip()) {
            char cur = stream_.peek();

            if (!isalnum(cur))
                break;

            result.push_back(cur);
        }

        return {result, IDENT};
    }

    Token scanNumber() {
        string result(1, stream_.next());

        for (; !stream_.empty(); stream_.skip()) {
            char cur = stream_.peek();

            if (!isdigit(cur))
                break;

            result.push_back(cur);
        }

        return {result, NUMBER};
    }

    Token scanSpecial() {
        int max_n = specials_[0].value.length();
        vector<char> symb = stream_.peekn(max_n);

        for (auto [value, type] : specials_) {
            if (value.length() <= symb.size()) {
                bool equal = true;

                for (size_t i = 0; i < value.length(); ++i) {
                    if (value[i] != symb[i]) {
                        equal = false;
                        break;
                    }
                }

                if (!equal)
                    continue;

                stream_.skip(value.size());
                return {value, type};
            }
        }

        error();

        return {"(T-T)", ERROR};
    }

    void error() { error_ = true; }

    void tokenize() {
        while (!stream_.empty() && !error_) {
            if (isdigit(stream_.peek()))
                tokens_.push_back(scanNumber());
            else if (isalpha(stream_.peek()))
                tokens_.push_back(scanIndent());
            else if (isspace(stream_.peek()))
                stream_.next();
            else
                tokens_.push_back(scanSpecial());
        }

        if (stream_.empty())
            tokens_.push_back({"", EOP});
    }

  public:
    Lexer(const string &s) : error_(false), stream_(s) {
        auto comp = [&](auto left, auto right) {
            auto [left_k, left_v] = left;
            auto [right_k, right_v] = right;
            return left_k.size() > right_k.size() ||
                   (left_k.size() == right_k.size() && left_k < right_k);
        };

        sort(specials_.begin(), specials_.end(), comp);

        tokenize();
    }

    vector<Token> tokens() { return this->tokens_; }
    bool success() { return !error_; }

    iterator begin() { return this->tokens_.begin(); }
    iterator end() { return this->tokens_.end(); }
};

class Parser {
  private:
    Stream<vector<Token>, Token> stream_;

    bool error_;

    int n_formulas_;
    int n_colors_;
    stringToInt from_;
    stringToInt colors_;
    stringSet used_;
    stringMap dependencies_;
    vector<string> working_variables_;

    bool checkSumOp() { return CHECK(PLUS) || CHECK(MINUS); }

    bool checkMulOp() { return CHECK(MUL) || CHECK(DIV); }

    void error(__attribute__((unused)) string expected) {
        // cout << "ERROR" << "\n";
        // cout << "expected: " << expected << "\n";
        // cout << "got: " << stream_.peek().value << "\n";
        error_ = true;
    }

    // formulas ::= formula { formula }
    void parseFormulas() {
        parseFormula();

        while (!error_ && CHECK(IDENT))
            parseFormula();
    }

    // formula ::= ident-list "=" exprs-list ";"
    void parseFormula() {
        if (!CHECK(IDENT))
            return error("IDENT");

        int n_vars = parseIdentList();

        ASSERT(SET);

        int n_exprs = parseExprList();

        ASSERT(SEP);

        if (n_exprs != n_vars)
            return error("Wrong number of arguments");

        for (auto var : working_variables_)
            colors_[var] = n_formulas_;

        ++n_formulas_;

        working_variables_.clear();
    }

    // ident-list ::= ident { "," ident }
    int parseIdentList() {
        int count = 0;

        while (1) {
            auto ident = stream_.next(); // ident
            working_variables_.push_back(ident.value);

            if (dependencies_.find(ident.value) != dependencies_.end()) {
                error("Repeating variable");
                return -1;
            }

            dependencies_[ident.value] = stringSet();
            from_[ident.value] = n_formulas_;
            ++count;

            if (!CHECK(COLON))
                break;

            stream_.skip();
        }

        return count;
    }

    // exprs-list ::= expr { "," expr }
    int parseExprList() {
        int count = 0;

        while (1) {
            parseExpr();
            ++count;

            if (!CHECK(COLON))
                break;

            stream_.skip();
        }

        return count;
    }

    // expr ::= term { sum-op term }
    void parseExpr() {
        parseTerm();

        while (checkSumOp()) {
            stream_.skip();
            parseTerm();
        }
    }

    // term ::= factor { mul-op factor }
    void parseTerm() {
        parseFactor();

        while (checkMulOp()) {
            stream_.skip();
            parseFactor();
        }
    }

    // factor ::= ident | number | "(" expr ")" | "-" factor
    void parseFactor() {
        if (CHECK(IDENT)) {
            auto ident = stream_.next(); // ident
            used_.insert(ident.value);

            for (auto k : working_variables_)
                dependencies_[k].insert(ident.value);

            return;
        }

        if (CHECK(NUMBER)) {
            stream_.next();
            return;
        }

        if (CHECK(LPAREN)) {
            stream_.next();
            parseExpr();
            ASSERT(RPAREN);
            return;
        }

        if (CHECK(MINUS)) {
            stream_.next();
            parseFactor();
            return;
        }

        error("ERROR");
    }

  public:
    Parser(const vector<Token> &tokens) : stream_(tokens), error_(false), n_formulas_(0) {
        if (!stream_.empty()) {
            parseFormulas();
            error_ = error_ or !CHECK(EOP);

            for (auto k : used_) {
                if (dependencies_.find(k) == dependencies_.end()) {
                    error_ = true;
                    break;
                }
            }
        }
    }

    bool success() { return !error_; }

    stringMap getDependencies() { return dependencies_; }
    stringToInt getColors() { return colors_; }
    stringToInt getLocations() { return from_; }
};

class Graph {
  private:
    stringToInt names_;
    vector<vi> adj_;
    vector<vi> adjT_;
    vi colors_;
    size_t size_;

  public:
    Graph(int n) : size_(0) {
        adj_.assign(n, vi());
        adjT_.assign(n, vi());
        colors_.assign(n, -1);
    }

    void addVertex(string name, int color = -1) {
        if (names_.find(name) == names_.end()) {
            names_[name] = size_++;
            colors_[names_[name]] = color;
        }
    }

    void addEdge(string from, string to) {
        int from_id = names_[from], to_id = names_[to];
        adj_[from_id].push_back(to_id);
        adjT_[to_id].push_back(from_id);
    }

    void print() {
        for (int v = 0; v < size_; ++v) {
            cout << v << " (" << colors_[v] << ")" << ": ";
            for (auto u : adj_[v]) {
                cout << u << " ";
            }
            cout << "\n";
        }
    }

    vi topsort() {
        vi inDegree(size_, 0);
        queue<int> q;
        vi order;

        for (int u = 0; u < size_; ++u) {
            for (auto v : adj_[u]) {
                ++inDegree[v];
            }
        }

        for (int u = 0; u < size_; ++u) {
            if (inDegree[u] == 0) {
                q.push(u);
            }
        }

        while (!q.empty()) {
            int u = q.front();
            order.push_back(u);
            q.pop();

            for (auto v : adj_[u]) {
                --inDegree[v];

                if (inDegree[v] == 0) {
                    q.push(v);
                }
            }
        }

        return order;
    }

    int getColor(int v) { return (v < size_ ? colors_[v] : -1); }
    size_t getSize() { return this->size_; }
};

string getFormulas() {
    string formulas = "", line;

    while (getline(cin, line))
        formulas += line + ";";

    return formulas;
}

Graph dependenciesToGraph(const stringMap &deps, stringToInt &colors) {
    int n = deps.size();
    Graph g(n);

    for (auto [key, _] : deps)
        g.addVertex(key, colors[key]);

    for (auto [key, values] : deps) {
        for (auto value : values) {
            g.addEdge(value, key);
        }
    }

    return g;
}

Graph getGraphFromParser(Parser &p) {
    auto deps = p.getDependencies();
    auto colors = p.getColors();
    return dependenciesToGraph(deps, colors);
}

vector<string> formulasToList(string formulas) {
    vector<string> result;
    string formula;

    for (stringstream ss(formulas); getline(ss, formula, ';');)
        result.push_back(formula);

    return result;
}

int main() {
    auto program = getFormulas();

    Lexer l(program);
    if (!l.success()) {
        cout << "syntax error\n";
        return 0;
    }

    Parser p(l.tokens());
    if (!p.success()) {
        cout << "syntax error\n";
        return 0;
    }

    auto g = getGraphFromParser(p);
    auto order = g.topsort();

    if (order.size() != g.getSize()) {
        cout << "cycle\n";
        return 0;
    }

    auto formulas = formulasToList(program);

    vector<bool> used(formulas.size(), false);

    for (auto v : order) {
        auto color = g.getColor(v);
        if (!used[color]) {
            cout << formulas[color] << "\n";
            used[color] = true;
        }
    }
}
